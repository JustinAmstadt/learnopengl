#version 430 core

// Work groups
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Output image

layout(rgba32f, binding = 0) uniform image2D imgOutput;

layout (binding = 1) buffer ShapeData {
    vec3 vertices[];
};

uniform float t;
uniform float ray_tmin;
uniform float ray_tmax;

const int NUM_SPHERES = 2;

// #include <include/structs.glsl>
// #include <include/ray.glsl>
// #include <include/hit_record.glsl>
// #include <include/sphere.glsl>

HitRecord hit_world(Sphere world[NUM_SPHERES], Ray r) {
    HitRecord rec = HitRecord(vec3(0.0, 0.0, 0.0),vec3(0.0, 0.0, 0.0), 0.0, true, true);
    HitRecord temp_rec = HitRecord(vec3(0.0, 0.0, 0.0),vec3(0.0, 0.0, 0.0), 0.0, true, true);
    bool hit_anything = false;
    float closest_so_far = ray_tmax;

    for (int i = 0; i < NUM_SPHERES; ++i) {
        temp_rec = hit_sphere(r, world[i], closest_so_far, rec);
        if (temp_rec.hit) {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            rec = temp_rec;
        }
    }

    rec.hit = hit_anything;
    return rec;
}

vec3 ray_color(Ray r, Sphere world[NUM_SPHERES]) {
    // Check intersection with sphere
    HitRecord rec = hit_world(world, r);
    if (rec.hit) {
        return 0.5 * (rec.normal + vec3(1,1,1));
    }

    vec3 unit_direction = normalize(r.direction);
    float a = 0.5 * (unit_direction.y + 1.0);
    return (1.0-a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0);
}

// Main function
void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(imgOutput);

    // Normalize pixel coordinates
    vec2 uv = (vec2(pixel_coords) / vec2(image_size)) * 2.0 - 1.0;

    // Camera setup
    vec3 ray_origin = vec3(0.0, 0.0, 0.0);
    vec3 ray_direction = normalize(vec3(uv.x, uv.y, -1.0));

    Ray ray = Ray(ray_origin, ray_direction);

    Sphere world[NUM_SPHERES];
    world[0].center = vec3(0.0, 0.0, -1.0);
    world[0].radius = 0.5;
    world[0].color = vec3(1.0, 0.0, 0.0);
    world[1].center = vec3(0.0, -100.5, -1.0);
    world[1].radius = 100;
    world[1].color = vec3(0.0, 1.0, 0.0);

    vec3 pixel_color = ray_color(ray, world);

    // Write color to output image
    imageStore(imgOutput, pixel_coords, vec4(pixel_color, 1.0));
}