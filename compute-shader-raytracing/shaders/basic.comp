#version 430 core

// Work groups
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Output image

layout(rgba32f, binding = 0) uniform image2D imgOutput;

// #include <include/structs.glsl>

// Function to intersect a ray with a sphere
float intersectSphere(Ray ray, Sphere sphere) {
    vec3 oc = ray.origin - sphere.center;
    float b = dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float h = b * b - c;

    if (h < 0.0) return -1;
    return -b - sqrt(h); // This is going to be t in our ray equation
}

vec3 ray_color(Ray r, Sphere sphere) {
    // Check intersection with sphere
    float t = intersectSphere(r, sphere);
    if (t > 0) {
        return sphere.color;
    }

    vec3 unit_direction = normalize(r.direction);
    float a = 0.5*(unit_direction.y + 1.0);
    return (1.0-a)*vec3(1.0, 1.0, 1.0) + a*vec3(0.5, 0.7, 1.0);
}

// Main function
void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(imgOutput);

    // Normalize pixel coordinates
    vec2 uv = (vec2(pixel_coords) / vec2(image_size)) * 2.0 - 1.0;
    uv.y = -uv.y;  // Flip y-coordinate

    // Camera setup
    vec3 ray_origin = vec3(0.0, 0.0, 0.0);
    vec3 ray_direction = normalize(vec3(uv.x, uv.y, -1.0));

    Ray ray = Ray(ray_origin, ray_direction);

    // Scene setup (simple scene with one sphere)
    Sphere sphere = Sphere(vec3(0.0, 0.0, -3.0), 1.0, vec3(1.0, 0.0, 0.0));  // Red sphere

    vec3 pixel_color = ray_color(ray, sphere);

    // Write color to output image
    imageStore(imgOutput, pixel_coords, vec4(pixel_color, 1.0));
}