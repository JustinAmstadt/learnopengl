#version 430 core

// Work groups
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Output image

layout(rgba32f, binding = 0) uniform image2D imgOutput;

// #include <include/structs.glsl>
// #include <include/ray.glsl>

// Function to intersect a ray with a sphere
float hit_sphere(Ray ray, Sphere sphere) {
    vec3 oc = sphere.center - ray.origin;
    float a = dot(ray.direction, ray.direction); // This is length squared
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float h = dot(ray.direction, oc);
    float discriminant = h * h - a * c;

    if (discriminant < 0.0) return -1;
    return (h - sqrt(discriminant)) / a; // This is going to be t in our ray equation
}

vec3 ray_color(Ray r, Sphere sphere) {
    // Check intersection with sphere
    float t = hit_sphere(r, sphere);
    if (t > 0) {
        vec3 N = normalize(rayAt(r, t) - sphere.center);
        return 0.5 * vec3(N.x + 1, N.y + 1, N.z + 1);
    }

    vec3 unit_direction = normalize(r.direction);
    float a = 0.5 * (unit_direction.y + 1.0);
    return (1.0-a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0);
}

// Main function
void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(imgOutput);

    // Normalize pixel coordinates
    vec2 uv = (vec2(pixel_coords) / vec2(image_size)) * 2.0 - 1.0;

    // Camera setup
    vec3 ray_origin = vec3(0.0, 0.0, 0.0);
    vec3 ray_direction = normalize(vec3(uv.x, uv.y, -1.0));

    Ray ray = Ray(ray_origin, ray_direction);

    // Scene setup (simple scene with one sphere)
    Sphere sphere = Sphere(vec3(0.0, 0.0, -1.0), 0.5, vec3(1.0, 0.0, 0.0));  // Red sphere

    vec3 pixel_color = ray_color(ray, sphere);

    // Write color to output image
    imageStore(imgOutput, pixel_coords, vec4(pixel_color, 1.0));
}