#version 430 core

// Work groups
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Output image

layout(rgba32f, binding = 0) uniform image2D imgOutput;

layout (binding = 1) buffer ShapeData {
    vec3 vertices[];
};

uniform float t;
uniform float ray_tmin;
uniform float ray_tmax;
uniform int samples_per_pixel;
uniform vec3 camera_center;
uniform int depth;

const int NUM_SPHERES = 2;

// #include <include/structs.glsl>
// #include <include/ray.glsl>
// #include <include/hit_record.glsl>
// #include <include/sphere.glsl>
// #include <include/random.glsl>

HitReturn hit_world(Sphere world[NUM_SPHERES], Ray r) {
    HitReturn return_val = HitReturn(HitRecord(vec3(0.0, 0.0, 0.0),vec3(0.0, 0.0, 0.0), 0.0, true), true);
    HitRecord temp_rec = HitRecord(vec3(0.0, 0.0, 0.0),vec3(0.0, 0.0, 0.0), 0.0, true);
    bool hit_anything = false;
    float closest_so_far = ray_tmax;

    for (int i = 0; i < NUM_SPHERES; ++i) {
        HitReturn temp_return = hit_sphere(r, world[i], closest_so_far);
        if (temp_return.hit) {
            hit_anything = true;
            closest_so_far = temp_return.rec.t;
            return_val.rec = temp_return.rec;
        }
    }

    return_val.hit = hit_anything;
    return return_val;
}

vec3 ray_color(Ray r, Sphere world[NUM_SPHERES], int pixel_index, int sample_index) {
    int bounceCount = 0;

    for (int i = 0; i < depth; ++i) {
        HitReturn hit_return = hit_world(world, r);

        if (hit_return.hit) {
            vec3 direction = random_on_hemisphere(pixel_index, sample_index, hit_return.rec.normal);
            r = Ray(hit_return.rec.p, direction);
            bounceCount++;
        } else {
            vec3 unit_direction = normalize(r.direction);
            float a = 0.5 * (unit_direction.y + 1.0);
            vec3 color = (1.0-a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0);

            for (int j = 0; j < bounceCount; ++j) {
                color *= 0.5;
            }

            return color;
        }

    }

    return vec3(0.0, 0.0, 0.0);
    /*
    // Check intersection with sphere
    HitReturn hit_return = hit_world(world, r);

    if (hit_return.hit) {
        // return 0.5 * (hit_return.rec.normal + vec3(1,1,1));
        vec3 direction = random_on_hemisphere(pixel_index, sample_index, hit_return.rec.normal);
        return 0.5 * ray_color(Ray(hit_return.rec.p, direction), world, pixel_index, sample_index);
    }

    vec3 unit_direction = normalize(r.direction);
    float a = 0.5 * (unit_direction.y + 1.0);
    return (1.0-a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0);
    */
}

vec3 sample_square(int pixel_index, int sample_index, vec2 image_size) {
    vec2 v = vec2(rand(pixel_index, sample_index) - 0.5, rand(pixel_index * 13, sample_index * 277) - 0.5);
    v -= v - 0.5; // Shift to [-0.5, 0.5]

    // To NDC
    v = v * 2.0 / image_size;
    return vec3(v, 0.0);
}

Ray get_ray(vec2 uv, int pixel_index, int sample_index, vec2 image_size) {
    vec3 offset = sample_square(pixel_index, sample_index, image_size);
    vec3 ray_origin = camera_center;
    vec3 ray_direction = normalize(vec3(uv, -1.0) + offset);

    return Ray(ray_origin, ray_direction);
}

// Main function
void main() {
    Sphere world[NUM_SPHERES];
    world[0].center = vec3(0.0, 0.0, -1.0 - t);
    world[0].radius = 0.5;
    world[0].color = vec3(1.0, 0.0, 0.0);
    world[1].center = vec3(0.0, -100.5, -1.0 - t);
    world[1].radius = 100;
    world[1].color = vec3(0.0, 1.0, 0.0);

    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(imgOutput);

    int pixel_index = pixel_coords.y * image_size.x + pixel_coords.x;

    // Convert to NDC
    vec2 uv = (vec2(pixel_coords) / vec2(image_size)) * 2.0 - 1.0;

    vec3 pixel_color = vec3(0.0, 0.0, 0.0);

    for (int i = 0; i < samples_per_pixel; ++i) {
        Ray ray = get_ray(uv, pixel_index, i, image_size);
        pixel_color += ray_color(ray, world, pixel_index, i);
    }

    // Average and clamp the values
    pixel_color = (1.0 / samples_per_pixel) * pixel_color;
    pixel_color = clamp(pixel_color, 0.000, 0.999);

    // Write color to output image
    imageStore(imgOutput, pixel_coords, vec4(pixel_color, 1.0));
}